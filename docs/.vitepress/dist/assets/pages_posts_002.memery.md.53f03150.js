import{_ as o,D as s,o as n,c as l,z as a,a as t,t as i,G as p,O as h}from"./chunks/framework.89d0ee0c.js";const U=JSON.parse('{"title":"虚拟内存","description":"","frontmatter":{"title":"虚拟内存","date":"2023-06-21T00:00:00.000Z","img":"https://s2.loli.net/2023/06/21/TrJHBfhdSYwRvc8.webp"},"headers":[],"relativePath":"pages/posts/002.memery.md","filePath":"pages/posts/002.memery.md"}'),d={name:"pages/posts/002.memery.md"},c={id:"frontmatter-title",tabindex:"-1"},m=a("a",{class:"header-anchor",href:"#frontmatter-title","aria-label":'Permalink to "{{ $frontmatter.title }} <Badge type="tip" :text="String($frontmatter.date).slice(0,10)" />"'},"​",-1),_=h('<h2 id="为什么要有虚拟内存" tabindex="-1">为什么要有虚拟内存 <a class="header-anchor" href="#为什么要有虚拟内存" aria-label="Permalink to &quot;为什么要有虚拟内存&quot;">​</a></h2><p>最开始，一台电脑上只能运行一个进程，除了操作系统所需要的空间，剩余所有都分配给当前进程，为了能让计算机能同时运行多个进程，于是有了多进程的机制，但只能共享一整个内存空间，而这些进程只能使用所规划好的内存空间，需要每次计算可使用的内存，这样也可能会读取别的进程的内存，于是有了虚拟内存。</p><p>为了让用户不再手动计算分配内存，于是可以事先声明进程可用内存大小，让每个进程拥有一片连续完整的内存空间，再由操作系统把虚拟内存映射到真实地址。这样应用程序就认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，如果有太多的进程导致虚拟内存的总量超过真实内存的大小，就会把部分用不到的内存暂时存储在外部磁盘存储器上，在需要时进行数据交换加载到真实内存，这个映射过程都由操作系统完成。</p><p><img src="https://s2.loli.net/2023/06/21/TrJHBfhdSYwRvc8.webp" alt="img"></p><h2 id="虚拟寻址" tabindex="-1">虚拟寻址 <a class="header-anchor" href="#虚拟寻址" aria-label="Permalink to &quot;虚拟寻址&quot;">​</a></h2><p>现代处理器使用虚拟寻址的方式处理映射，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中一个被称为内存管理单元（Memory Management Unit, MMU）的硬件。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。</p><h2 id="页面置换算法" tabindex="-1">页面置换算法 <a class="header-anchor" href="#页面置换算法" aria-label="Permalink to &quot;页面置换算法&quot;">​</a></h2><p>地址映射过程中，若在页面中发现所要访问的页面被放在磁盘中不在内存中，则产生缺页中断 。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法，页面置换算法的作用是 实现虚拟存储管理。</p><ul><li><strong>OPT页面置换算法（最佳页面置换算法）</strong> ：理想情况，不可能实现，一般作为衡量其他置换算法的方法。</li><li><strong>FIFO页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li><strong>LRU页面置换算法（最近未使用页面置换算法）</strong> ：LRU（Least Currently Used）算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间T，当须淘汰一个页面时，选择现有页面中其T值最大的，即最近最久未使用的页面予以淘汰。</li><li><strong>LFU页面置换算法（最少使用页面排序算法）</strong> : LFU（Least Frequently Used）算法会让系统维护一个按最近一次访问时间排序的页面链表，链表首节点是最近刚刚使用过的页面，链表尾节点是最久未使用的页面。访问内存时，找到相应页面，并把它移到链表之首。缺页时，置换链表尾节点的页面。也就是说内存内使用越频繁的页面，被保留的时间也相对越长。</li></ul><p>相关链接</p><ol><li><a href="https://zhuanlan.zhihu.com/p/85760403" target="_blank" rel="noreferrer">什么是虚拟内存？| 一分钟系列</a></li><li><a href="https://zhuanlan.zhihu.com/p/82746153" target="_blank" rel="noreferrer">什么是虚拟内存(Virtual Memory)?</a></li></ol>',11);function f(e,g,u,T,b,y){const r=s("Badge");return n(),l("div",null,[a("h1",c,[t(i(e.$frontmatter.title)+" ",1),p(r,{type:"tip",text:String(e.$frontmatter.date).slice(0,10)},null,8,["text"]),t(),m]),_])}const S=o(d,[["render",f]]);export{U as __pageData,S as default};
